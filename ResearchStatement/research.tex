\documentclass[11pt]{article}



\usepackage{url}
\usepackage{color}
\usepackage{breakurl}
\newcommand{\bburl}[1]{\textcolor{blue}{\url{#1}}}

\newcommand{\Rescue}{\textsc{Rescue}}

 \addtolength{\textwidth}{5cm}
 \addtolength{\textheight}{5cm}
 \addtolength{\hoffset}{-2.5cm}
  \addtolength{\voffset}{-3cm}
 \addtolength{\marginparwidth}{-2cm}

 \newcommand{\myparagraph}[1]{\medskip\noindent{\it \textbf{#1.}}}
\begin{document}
\title{Research Statement}
\author{Minseok Jeon}
\date{}
\bibliographystyle{plain}

\newcommand{\DisjunctiveModel}{{``Disjunctive Model''}}
\newcommand{\FeatureLanguage}{{``Feature Language''}}
\newcommand{\GDL}{{``Graph Description Language''}}


\newcommand{\AbstractRelativeWritePattern}{{``Abstract Relative Write Pattern''}}

\maketitle 

My research aims to design domain-specific programming languages and program synthesis algorithms to address challenges in programming languages and software engineering. 
%
More specifically, my research focuses on designing domain-specific programming languages (DSLs) that include solutions for given programming language or software engineering problems, along with program synthesis algorithms that automatically find these solutions within the DSLs.
%
More specifically, my research aims to design domain-specific languages (DSLs) that would describe solutions for specific problems in programming language or software engineering. 
%
Subsequently, my research develops program synthesis algorithms that automatically search for these solutions within the DSLs.
%
I have developed DSLs and program synthesis algorithms for generating powerful analysis heuristics in pointer analysis, a key ingredient in compiler optimization.
%
I have also designed DSLs for generating effective test cases in system software testing.
%
My research has demonstrated that my DSL-based approaches are effective in addressing certain problems that they outperform existing techniques.
%
My DSL-based approach is just started, and there are many challenges and opportunities for improvement.
%
My future work will be dedicated to addressing these challenges and generalizing the approach to address problems in other domains.





\section{DSLs \& Synthesis Algorithms for Automatically Generating Effective Pointer Analysis Heuristics}
%
The goal of pointer analysis is to approximate the set of memory locations that a pointer variable may point to during program execution.
%
Pointer analysis is a key ingredient in compiler optimization, and it is also widely used in many other software engineering techniques, including bug detection, security analysis, and program repair.
%
The success of pointer analyzers heavily depends on the quality of their underlying analysis heuristics.
%
Without high-quality analysis heuristics, the analysis becomes imprecise or too expensive.
%
Before my research, those heuristics had been manually designed by domain experts. 
%
However, manually designing analysis heuristics requires time-consuming and laborious tasks.
%
Even worse, the manually crafted heuristics have shown suboptimal performance.
%
To address this problem, I have designed domain-specific languages that are expressive enough to describe high-quality analysis heuristics and program synthesis algorithms that effectively search the high-quality heuristics in the DSLs.



\subsection{DSL \& Synthesis Algorithms for Automatically Generating Selective Context Sensitivity Heuristics~\cite{JeJeChOh17,Jeon2019}}
%
Context sensitivity is one of the most impactful factors that improves the precision of pointer analysis by distinguishing variables and objects in different calling contexts.
%
Applying context sensitivity to all methods, however, is too expensive in practice.
%
Selective context sensitivity addresses this problem by selectively applying context sensitivity to methods.
%
To effectively apply selective context sensitivity, qualified heuristics are essential to accurately determine whether each method should be analyzed with context sensitivity.




In this work, I designed a domain-specific language, called \DisjunctiveModel, that describes various selective context sensitivity heuristics.
%
Simultaneously, I designed a program synthesis algorithm that automatically generates qualified selective context sensitivity heuristics from the DSL.
%
The experimental results show that the DSL-based approach automatically generates outstanding analysis heuristics that outperform the existing manually designed heuristics in practice.


%%ToDo
\subsection{DSL \& Synthesis Algorithms for Generating Context Tunneling Heuristics~\cite{JeJeOh18}}
%
In static analysis, context abstraction is essential as it is impractical to keep all concrete contexts. 
%
The dominant context abstraction method is $k$-limited context sensitivity, which keeps only the last $k$ context elements.
%
However, the last-$k$ context abstraction has a significant limitation: it may remove key context elements if they do not belong to the last $k$ context elements, significantly degrading the precision of the analysis.




To address this problem, I proposed context tunneling~\cite{JeJeOh18}, which enables the $k$-limited context sensitivity to keep the most important $k$-context elements instead of the last-$k$ context elements.
%
To apply context tunneling, however, context tunneling heuristics are required to determine whether each context element is important.
%
I adapted the \DisjunctiveModel~and the synthesis algorithm to generate high-quality context tunneling heuristics from the DSL.
%
The experimental results show that the produced context tunneling heuristics significantly improved the effectiveness of the $k$-limited context-sensitive analyses.



\subsection{A Synthesis Algorithm for Transforming a Given Object Sensitivity into a More Precise Call-Site Sensitivity~\cite{JeOh22}}
%
In OOP (Object-Oriented Programming) program analysis, object sensitivity has been established as the dominant context flavor.
%
The superiority of object sensitivity over other context flavors has been reinforced by extensive research.
%
On the other hand, call-site sensitivity has been consistently dismissed because it has shown poor performance in both precision and scalability.
%
However, I found that this superiority of object sensitivity over call-site sensitivity does not hold when context tunneling~\cite{JeJeOh18} is included. 


In this work, we challenged the commonly accepted knowledge by developing a synthesis algorithm that transforms a given object sensitivity into a more precise call-site sensitivity.
%
The synthesis algorithm takes a tunneling heuristic of an object sensitivity and produces a corresponding tunneling heuristic, described as \DisjunctiveModel, for call-site sensitivity.
%
The experimental results show that the transformed call-site sensitivity is significantly more precise and scalable than the given object sensitivity.




\subsection{DSL \& Synthesis Algorithms for Automatically Generating Features~\cite{Jeon20}}
%
This work addresses a key burden of using \DisjunctiveModel. 
%
\DisjunctiveModel~combines user-provided features to describe analysis heuristics; the success of \DisjunctiveModel~heavily depends on the quality of user-provided features.
%
However, designing high-quality features is a nontrivial and laborious task for users.
%
To remove this burden, I designed a framework that automatically generates high-quality features.
%
To this end, I designed a domain-specific language, called \FeatureLanguage, that describes various features.
%
Subsequently, I developed a synthesis algorithm that automatically generates qualified features from \FeatureLanguage.
%
The experimental results demonstrate that our \FeatureLanguage-based approach successfully generates high-quality features, enabling the learning of effective heuristics without the need for user-provided features.


\section{DSL \& Synthesis Algorithms for Generating Effective Inputs for Software Testing}
%
In system software testing, designing test cases has also been done manually by domain experts; it faces the same challenges.
%.
It requires laborious efforts, and the manually crafted test cases often yield suboptimal results.
%
To address this issue, I have developed a domain-specific language for generating effective test cases in system software testing.


\subsection{Domain-Specific Language for Generating Effective Test Cases in Endurance Test for Flash-based Storage Devices~\cite{ARES23}}

Flash-based storage devices are widely used in practice, including mobile devices, laptops, and servers. 
%
However, flash-based storage devices have a finite limit in processing data write requests.
%
Therefore, it is crucial for manufacturers to rigorously test and accurately provide the maximum data write capacity that their products can reliably endure.
%
To automate the generation of effective test cases for the endurance test, I designed a domain-specific language named \AbstractRelativeWritePattern, which effectively reduces the search space of test cases.
%
Then, I developed a synthesis algorithm that automatically generates qualified test cases using the DSL.
%
The experimental results show that the DSL-based approach successfully generates qualified test cases that outperform the existing manually designed test cases used in practice.



\section{Future Research Plan}
I believe that my DSL-based approaches are promising and have a lot of opportunities for improvement, with the potential to extend their applicability to various other fields.
%
In my future work, I plan to focus on expanding the use of DSL-based techniques to other domains, while also addressing the existing challenges and limitations in the current methods.


\subsection{Improving My DSL-based Approach}

The current DSL-based techniques for pointer analysis have several limitations, which I plan to address in my future work.

\myparagraph{Generating Combinations of Analysis Heuristics}
Practical static analyzers use combinations of various analysis heuristics.
%
This necessitates heuristic design processes to consider the interactions among these heuristics.
%
However, my previous approaches lacked consideration of these combinations.
%
My previous approaches have focused on generating a single analysis heuristic without considering interactions with other heuristics.
%
Recently, I observed that blindly combining the analysis heuristics results in suboptimal performance.
%
To address this problem, I plan to improve my DSL-based approach to generate combinations of analysis heuristics.
%
To achieve this, I will first identify and clarify the properties and relationships between different analysis heuristics.
% 
Then, I will design DSLs and synthesis algorithms based on these properties and relationships.




\myparagraph{Understanding the Principles Behind the Generated Heuristics}
Though effective, the analysis heuristics produced from the DSL-based approaches are currently considered as black-box heuristics that do not explain why they are effective in pointer analysis.
%
Unlike neural network-based approaches, our DSL-based approaches are interpretable as they are described using symbols (e.g., DNF formulas).
%
Understanding the symbols in the learned heuristics can lead to an understanding of the principles behind the learned heuristics.
%
I would like to note that understanding the principles behind the learned heuristics is valuable as it will provide key insights when designing analysis heuristics.



To understand the principle behind the learned heuristics, I plan to design a framework that will transform a produced heuristic into a simplified version while maintaining its effectiveness.
%
Currently, the learned analysis heuristics consist of complex DNF formulas, and this complexity poses a significant challenge in understanding the essence of the learned heuristics.
%
The goal of this framework is to compile a given complex analysis heuristic into a simpler form, making interpretation much easier.
%
Additionally, this simplification process may lead to the generalization of the learned heuristics, potentially enhancing their performance.



\subsection{Generalizing My DSL-based Approach to Other Domains}
I am currently working on extending my DSL-based approach to other domains.
%
Currently, I am applying my DSL-based approach to fault localization and explainable graph machine learning.

\myparagraph{DSL-based Approach for Fault Localization}
The goal of fault localization is to identify the locations of faults in programs that occur errors.
%
Currently, ``Spectrum-Based Fault Localization'' (SBFL) is the dominant fault localization technique widely used in practice because of its efficiency.
%
SBFL, however, has a limitation in accuracy; it often fails to identify the locations of faults.
%
To address this problem, I am in the process of developing a DSL-based approach to improve the accuracy of SBFL.


Our approach is based on an observation that similar faults have redundantly appeared in the same projects; faults in a previous version of a project are likely to occur again in subsequent versions.
%
Based on this observation, I designed a domain-specific language that describes various fault patterns.
%
Using the DSL, our synthesis algorithm learns fault patterns from the previous versions of a project.
%
These learned fault patterns are then applied to enhance the accuracy of SBFL in the next version of the project.
%
When a new version of a project is released, our approach automatically generates a spectrum-based fault localization technique tailored specifically for the project by utilizing the patterns learned from previous versions.



\myparagraph{DSL-based Approach for Explainable Graph Machine Learning}
Our approach can also be generalized to develop an inherently explainable graph machine learning method. 
%
Many significant real-world problems can be modeled as graph machine learning problems, including fraud detection, program repair, and drug discovery.
%
In such decision-critical applications, users need to understand why the model made each prediction.
%
However, the dominant neural-network based graph machine learning models (i.e., graph neural networks), are black-boxes that do not explain why they made each prediction.
%
To address this problem, I designed a domain-specific language, called \GDL, and synthesis algorithms for automatically generating inherently explainable graph machine learning models that provide explanations describing the reasons behind the predictions.
%
The experimental results show that our DSL-based approach successfully generated inherently explainable graph machine learning models that have comparable accuracy to the existing neural network-based models but provide significantly better explanations for the predictions.
%
Recently, I submitted a research paper with the preliminary results.
%
Based on this work, I will lead DSL-based machine learning for explainable AI.



\bibliography{refs}


\end{document}


